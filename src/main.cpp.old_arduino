#include <Arduino.h>
#include <WiFi.h>

// Replace with your network credentials
const char *ssid =     "VodafoneRibes"; //"Mi 10";
const char *password = "scheggia2000"; // "12345678"; //


/*#include "BluetoothSerial.h"
// controlliamo se i registri che abilitano il Bluetooth
// sono stati correttamente configurati.
#if !defined(CONFIG_BT_ENABLED) || !defined(CONFIG_BLUEDROID_ENABLED)
#error Bluetooth non è stato abilitato.
#endif */

// Ogetto della seriale Bluetooth a cui associamo l'identificativo SerialBT
/*BluetoothSerial SerialBT;
String BTmessage = "";
char incomingBTChar;
int BTcomando_letto = 0; */



#include <Wire.h>
#include <AHT10.h>


uint8_t readStatus = 0;
AHT10 myAHT10(AHT10_ADDRESS_0X38);

#include <AsyncTCP.h>
#include <ESPAsyncWebServer.h>

// Create AsyncWebServer object on port 80
AsyncWebServer server(80);

// Create a WebSocket object
AsyncWebSocket ws("/ws");

// Initialize WiFi
void initWiFi() {
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);
  Serial.print("Connecting to WiFi ..");
  while (WiFi.status() != WL_CONNECTED) {
    Serial.print('.');
    delay(1000);
  }
  Serial.println("");
  Serial.print("Connected to ");
  Serial.println(ssid);
  Serial.print("IP address: ");
  Serial.println(WiFi.localIP());
  Serial.print("MAC address: ");
  Serial.println(WiFi.macAddress());
  Serial.print("RRSI: ");
  Serial.println(WiFi.RSSI());
}

#include "SPIFFS.h"

int i;
long i2;
long j;

#define LED 19



struct bloccogiornaliero {
  uint8_t mtemperatura[10+60*24];       //10 per intestazione+60 minuti per 24 ore, una misura al minuto  1440 misure totali
  uint8_t mumidita[10+60*24];
  //uint8_t flags[10+60*24];    NON CI STA
  uint16_t dayofyear;   //giorno dell'anno 0-365    a 9999 se non inizializzato
  uint16_t indicescrittura;  //puntatore all'ultimo carattere scritto (10-1449)
};

bloccogiornaliero archivio[7];

const char* ntpServer = "pool.ntp.org";
const long  gmtOffset_sec = 3600;
const int   daylightOffset_sec = 3600;

uint8_t bancoselezionato=0;


struct tm timeinfo;
void printLocalTime()
{
  
  if(!getLocalTime(&timeinfo)){
    Serial.println("Failed to obtain time");
    return;
  }
  Serial.println(&timeinfo, "%A, %B %d %Y %H:%M:%S");
}

bool sendLocalTime()
{
  if(!getLocalTime(&timeinfo)){
    Serial.println("Failed to obtain time");
    return false;
  }

 char messaggiotemp [80];
 sprintf(messaggiotemp, "D %04d %02d %02d  %02d %02d %02d %1d", timeinfo.tm_year+1900,timeinfo.tm_mon+1,timeinfo.tm_mday,timeinfo.tm_hour,timeinfo.tm_min,timeinfo.tm_sec,timeinfo.tm_wday);
 Serial.print(messaggiotemp);
 ws.textAll(messaggiotemp);
 return(true);
}



unsigned int programma [230];  //per la descrizione vedere il file "descrizione fileprog"
char intestazioni[40];  //string 10 caratteri intestzione programmi. 
String messaggio; //conterrà copia del file fileprog.txt


void sendprogramma(bool send){   //se send è falso esegue solo il print
  
  /*char buflavoro[906];  
  i2=0;
  j;
  i2+=sprintf(buflavoro,"P  [");
  for (j=0;j<230;j++){
    i2+=sprintf(buflavoro+i2,"%03d,",programma[j]);
  }
  for(j=0;j<40;j++){
    buflavoro[i2]=intestazioni[j];
    i2++;
  }
  sprintf(buflavoro+i-1,"]");  //toglie l'ultima virgola*/
  Serial.print(messaggio); 
  if (send) ws.textAll(messaggio);
}

/*
void printprogramma(){
  
  char buflavoro[200];
  i=0;
  j;
  i+=sprintf(buflavoro,"P [");
  for (j=0;j<26;j++){
    i+=sprintf(buflavoro+i-1,"%d,",programma[j]);
  }
  sprintf(buflavoro+i,"]");  
  Serial.println(buflavoro);
  
}
*/



String sliderValue = "0";
int dutyCycle;

void handleWebSocketMessage(void *arg, uint8_t *data, size_t len) {
  AwsFrameInfo *info = (AwsFrameInfo*)arg;
  if (info->final && info->index == 0 && info->len == len && info->opcode == WS_TEXT) {
    data[len] = 0;
    sliderValue = (char*)data;
    dutyCycle = map(sliderValue.toInt(), 0, 100, 0, 255);
    
  }
}


void mandabloccodati(){         //manda i dati di tutta la settimana
  for(i=0;i<7;i++){
    
    if(archivio[i].indicescrittura<1450){  //manda il buffer solo se l'indice è inizializzato (altrimenti è 9999)
      archivio[i].mtemperatura[0]='T';  // marker di bufffer temperature
      archivio[i].mtemperatura[1]=(uint8_t)i;    //indica il giorno della settimana di riferimento
      archivio[i].mtemperatura[2]=(uint8_t)(archivio[i].indicescrittura/256);  //salva puntatore attuale di scrittura
      archivio[i].mtemperatura[3]=(uint8_t)archivio[i].indicescrittura%256;
      ws.binaryAll(&archivio[i].mtemperatura[0], 1450);

        
      archivio[i].mumidita[0]='U';  // marker di bufffer umidita
      archivio[i].mumidita[1]=(uint8_t)i;    //indica il giorno della settimana di riferimento
      archivio[i].mumidita[2]=(uint8_t)(archivio[i].indicescrittura/256);  //salva puntatore attuale di scrittura
      archivio[i].mumidita[3]=(uint8_t)archivio[i].indicescrittura%256;
      ws.binaryAll(&archivio[i].mumidita[0], 1450);
 
     
 
    } else {   // solo per prova

      archivio[i].mtemperatura[0]='T';  // marker di bufffer temperature
      archivio[i].mtemperatura[1]=(uint8_t)i;    //indica il giorno della settimana di riferimento

    //riempie il buffer con una serie di datoi che parte da 90+i*10 e arriva fino a 90+i*10+5*10 - parte da 9+i gradi e arriva a 9+5+i gradi

      for(j=10;j<1450;j++){
        archivio[i].mtemperatura[j]=90+i*10+50*(j-10)/1440;
      }

      archivio[i].mtemperatura[2]=(uint8_t)(archivio[i].indicescrittura/256);  //salva puntatore attuale di scrittura
      archivio[i].mtemperatura[3]=(uint8_t)archivio[i].indicescrittura%256;
      ws.binaryAll(&archivio[i].mtemperatura[0], 1450);

      archivio[i].mtemperatura[0]='T';  // marker di bufffer temperature
      archivio[i].mtemperatura[1]=(uint8_t)i;    //indica il giorno della settimana di riferimento




       archivio[i].mumidita[0]='U';  // marker di bufffer umidita
      archivio[i].mumidita[1]=(uint8_t)i;    //indica il giorno della settimana di riferimento

    //riempie il buffer con una serie di datoi che parte da 90+i*10 e arriva fino a 90+i*10+5*10 - parte da 9+i gradi e arriva a 9+5+i gradi
    //alterna il flag Acceso (bit 7) ogni 50*(i+1) valori
      uint8_t datodascrivere;
      for(j=10;j<1450;j++){
        datodascrivere=5+i*5+50*(j-10)/1440;
        if (j%(100*(i+1))>(100*(i+1))/2) datodascrivere+=128;
        archivio[i].mumidita[j]=datodascrivere;
      }

      archivio[i].mumidita[2]=(uint8_t)(archivio[i].indicescrittura/256);  //salva puntatore attuale di scrittura
      archivio[i].mumidita[3]=(uint8_t)archivio[i].indicescrittura%256;
      ws.binaryAll(&archivio[i].mumidita[0], 1450);


   

    }
    
  }
}

void leggifileprog(){
File file = SPIFFS.open("/fileprog.txt");
  if(!file){
    Serial.println("Failed to open file for reading");
  }
  else{
  
   /*String messaggio="";
    
    while(file.available()){
      //Serial.write(file.read());
      messaggio+=char(file.read());
    }
    
    file.close();
    Serial.println(messaggio); */

    messaggio = file.readString();
    Serial.println(messaggio);
    Serial.print("lunghezza messaggio: ");
    Serial.println(messaggio.length());
    file.close();
    
    char buflavoro[4];
    i2=0;
    for (i2=0;i2<230;i2++){      
      buflavoro[0]=char(messaggio[i2*4+4]);  
      buflavoro[1]=char(messaggio[i2*4+5]);
      buflavoro[2]=char(messaggio[i2*4+6]);
      buflavoro[3]=0;
      unsigned int k=atoi(buflavoro);
      programma[i2]=k;
    }
    j=0;
    for (i2=865;i2<905;i2++) {
        intestazioni[j]=messaggio[i2];
        j++;
    } 
    
  }
  
}


void onEvent(AsyncWebSocket *server, AsyncWebSocketClient *client, AwsEventType type,
             void *arg, uint8_t *data, size_t len) {
  Serial.print("ricevuto: ");
 
  
  switch (type) {
    case WS_EVT_CONNECT:
      Serial.printf("WebSocket client #%u connected from %s\n", client->id(), client->remoteIP().toString().c_str());
      ws.textAll("B "+ String(bancoselezionato));
      sendprogramma(true);
      if (sendLocalTime()) mandabloccodati();
      break;
    case WS_EVT_DISCONNECT:
      Serial.printf("WebSocket client #%u disconnected\n", client->id());
      break;
    case WS_EVT_DATA:
      handleWebSocketMessage(arg, data, len);
      Serial.println((char*)data);
      Serial.println((char)data[0]);
      if (char(data[0])=='P') {
        Serial.println("ERA P!!!");
        
        char buflavoro[4];
        i2=0;
        for (i2=0;i2<230;i2++){      
          buflavoro[0]=char(data[i2*4+4]);
          buflavoro[1]=char(data[i2*4+5]);
          buflavoro[2]=char(data[i2*4+6]);
          buflavoro[3]=0;
          unsigned int k=atoi(buflavoro);
          programma[i2]=k;
          Serial.print(k);
        }
        j=0;
        for (i2=865;i2<905;i2++){
            intestazioni[j]=data[i2];
            j++;
        }

        File file = SPIFFS.open("/fileprog.txt", FILE_WRITE);
        if(!file){
          Serial.println("Failed to open file for writing");
          return;
        }
    
        if(file.print((char*)data)){
          Serial.println("- file written");
        } else {
          Serial.println("- write failed");
        }
        file.close();

        leggifileprog();  //rilegge il file appena scritto e aggiorna i vari parametri

      }

    
      
      break;
    case WS_EVT_PONG:
    case WS_EVT_ERROR:
      break;
  }
}

void initWebSocket() {
  ws.onEvent(onEvent);
  server.addHandler(&ws);
}

void initSPIFFS() {
if (!SPIFFS.begin(true)) {
Serial.println("An error has occurred while mounting SPIFFS");
}
Serial.println("SPIFFS mounted successfully");
}


void setup() {
// put your setup code here, to run once:
Serial.begin(115200);
//SerialBT.begin("ESP32");
pinMode(LED, OUTPUT);

initSPIFFS();

leggifileprog();  
 

initWiFi();

configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);
printLocalTime();




while (myAHT10.begin() != true)
{
    Serial.println("AHT10 not connected or fail to load calibration coefficient"); 
    delay(5000);
}
Serial.println(F("AHT10 OK"));

   

  // Web Server Root URL
  server.on("/", HTTP_GET, [](AsyncWebServerRequest *request) {
    request->send(SPIFFS, "/index.html", "text/html");
  });


  server.serveStatic("/", SPIFFS, "/");

  /*

  server.on("/currentValue", HTTP_GET, [](AsyncWebServerRequest *request) {
    request->send(200, "/text/plain", String(sliderValue).c_str());
  //request->send(200, "/text/plain", String(temperatura).c_str());
  });

  */
  initWebSocket();
  // Start server
  server.begin();

 
  for (i=0;i<7;i++) {   //inizializza i 7 buffer di dati con giorno dell'anno e l'indice di scrittura =9999 per dichiararli vuoti
    archivio[i].dayofyear=9999;
    archivio[i].indicescrittura=9999;
  }





}


uint8_t acceso=0;
float offsettemp=0;
uint8_t wkday;
uint16_t indice;
uint8_t sogliaattuale;

uint8_t siamoineccezione=0;  //Non siamo in eccezione

bool eccezione() {
  if (programma[215]==0) { //se eccezione non abilitata
    (siamoineccezione=0);
    return (false);
  }
  Serial.print(" EX ");
  //se siamo oltre la data di fine siamo usciti
  if ((timeinfo.tm_mon+1)>programma[219]) return false; //non siamo in eccezione, oltre il mese di fine
  if ((timeinfo.tm_mon+1)==programma[219]) {
      //se siamo nel mese di fine controlla il giorno, altrimenti va a controllare l'inizio
    if (timeinfo.tm_mday>programma[218]) return false;  //siamo oltre la fine eccezione'eccezione
  }
  //verifica se siamo oltre l'inizio
  if ((timeinfo.tm_mon+1)<programma[217]) return false;  //siamo in un mese che precede l'inzio dell'eccezione
  if ((timeinfo.tm_mon+1)==programma[217]) { //se il mese corrisponde al mese di inizio controlliamo il giorno. Se è successivo siamo in eccezione
    if (timeinfo.tm_mday<programma[216]) return false;  //siamo prima dell'inizio eccezione
  }  
  //siamo in eccezione
  siamoineccezione=1;
  bancoselezionato=programma[220];
  return(true);
   
}


bool inconnessione=false;
uint contaconnessioni=0;
String diag="";

void loop() {
// put your main code here, to run repeatedly:

  /*if (SerialBT.available()){
    char incomingBTChar = SerialBT.read();
    if (incomingBTChar != '\n'){
      BTmessage += String(incomingBTChar);
    
    }
    else {
      if (BTcomando_letto == 1)   {
        
        BTmessage = "";
        BTcomando_letto = 0;
      }
      else
      {
      BTmessage = "";
      BTcomando_letto = 0;
      
      Serial.println("Comando errato");
      SerialBT.println("Comando errato");
      
      }
    }
    Serial.write(incomingBTChar);  
  }
  
  if (BTmessage =="A"){
    //digitalWrite(led, LOW);
    BTcomando_letto = 1;
  }
  else if (BTmessage =="B"){
    //digitalWrite(led, HIGH);
    BTcomando_letto = 1;
  } */




    ws.cleanupClients();


    float temperature = myAHT10.readTemperature();
    float humidity = myAHT10.readHumidity();
  
    
    

    Serial.print("Temperature: (");
    Serial.print(temperature);
    Serial.print(" ");
    temperature+=((float)static_cast<int8_t>(programma[203]))/10;
    Serial.print(static_cast<int8_t>(programma[203]));  //visualizza la correzione
    Serial.print(") ");
    Serial.print(temperature);
    Serial.print("°C -- Humidity: ");
    Serial.print(humidity);
    Serial.print("%  ----  ");


    
   
    ws.textAll("T "+ String(temperature));
    ws.textAll("U "+ String(humidity));
    

    if (Serial.available()) {
    String comando = Serial.readString();
    Serial.print("R-> ");
    Serial.println(comando);
    sendprogramma(false);   //esegue solo il print
    // fai qualcosa con il comando letto
    } 
 
    
    if (sendLocalTime()){

      sogliaattuale=0;

      //verifica quale soglia deve utilizzare
    
      
      diag=" ";  
      if (programma[201]!=0){  //impostazione manuale
        Serial.print(" MA ");
        diag+="MA";
        sogliaattuale=programma[202];
      } else {
        if(!eccezione()){    //in caso di eccezione il valore viene impostato secondo l'eccezione

          //siamo in programma automatico
          Serial.print(" AU ");
          diag+="AU";
          if (programma[221]==0){   //programma unico o settimanale?
            //programma unico
            Serial.print(" PU ");
            diag+="PU";
            bancoselezionato=programma[222];
          } else{
            //programma settimanale
            Serial.print(" PS ");
            diag+="PS";
            bancoselezionato=programma[223+wkday];
          }
        }
          //siccome lavoriamo a intervalli di mezz'ora per sapere in quale elemento stiamo lavorando dobbiamo sapere se è passata la mezzora
          //da non fare se siamo in manuale
          Serial.print(" SS ");
          diag+="SS";
          j=timeinfo.tm_hour*2;
          if (timeinfo.tm_min>=30) j++;
          sogliaattuale=programma[bancoselezionato*50+j];
      }

    }   //if (sendLocalTime()){

    ws.textAll("B "+ String(bancoselezionato)+" Conn: "+String(contaconnessioni)+" Heap: "+ESP.getFreeHeap()+diag);
    

    //per aggiungere un pò di isteresi al valore di temperatura tolgo il valore di acceso. 
    //quindi se acceso la temperatura risulta più bassa di 0.1*isteresi (programma[214]) gradi
    
    if (((temperature*10+programma[214]/2-acceso*programma[214])<sogliaattuale)&&(programma[200]!=0)) {   //se sotto temperatura e attualmente acceso e impostazione acceso/spento=acceso
      digitalWrite(LED, HIGH);
      acceso=1;
      ws.textAll("A ");
    } else{
      digitalWrite(LED, LOW);
      acceso=0;
      ws.textAll("S ");
    }
    Serial.print(" Soglia: ");
    Serial.print(sogliaattuale);
    Serial.print(" Banco: ");
    Serial.print(bancoselezionato);
    Serial.print(" Wifi: ");
    Serial.print(WiFi.status());
    Serial.print(" conn: ");
    Serial.print(contaconnessioni);

    if ((!inconnessione)&&(WiFi.status()!=WL_CONNECTED)){
      inconnessione=true;
      contaconnessioni++;
      WiFi.begin();

    }

    if (WiFi.status()==WL_CONNECTED) inconnessione=false;

    Serial.print(" Heap: ");
    Serial.println(ESP.getFreeHeap());




    //se siamo qui dentro significa che è stata letta una informazione di tempo.
    //se nella posizione corrispondente al giorno della settimana il giorno del'anno non corrisponde vuol dire che siamo passati a un nuovo giorno e quindi 
    //devo inizializzare il buffer corrispondente
    wkday=timeinfo.tm_wday;
    if (archivio[wkday].dayofyear!=timeinfo.tm_yday) {
      
        //inizializzo il buffer
        archivio[wkday].dayofyear=timeinfo.tm_yday;
      for(j=0;j<1450;j++){
        archivio[wkday].mtemperatura[j]=0;
        archivio[wkday].mumidita[j]=0;
      }
    }

    //ora vedo se devo scrivere
    indice=timeinfo.tm_hour*60+timeinfo.tm_min+10;    //numero del minuto nella giornata+10 bytes di intestazione del buffer
    if(archivio[wkday].indicescrittura !=indice){
      //se l'indice non corrisponde devo scrivere
      archivio[wkday].indicescrittura =indice;
      archivio[wkday].mtemperatura[indice]= (uint8_t) (temperature*10);
      archivio[wkday].mumidita[indice]= (uint8_t) (humidity)+acceso*128;
      
      //solo come test
      Serial.print("indice= ");
      Serial.print(indice);
      Serial.print(" ");
      j=indice-10;
      // if (j<0) j=0;   cancellato perchè comunque ci sono 10 bytes di intestazione
      for (;j<indice;j++){
        if (j>=1440) break;
        Serial.print(archivio[wkday].mtemperatura[j]);
        Serial.print(" ");
      }
      Serial.println("-");
      //ws.binaryAll(&archivio[wkday].mtemperatura[0], 1450);
      mandabloccodati();
      
    }
    
    
    delay(1000);
}