<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#667eea">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="manifest" href="/manifest.json">
    <link rel="apple-touch-icon" href="/icon-192.png">
    <link rel="icon" type="image/png" href="/icon-192.png">
    <title>Cronotermostato</title>

    <script>
        // Toggle fullscreen
        function toggleFullscreen() {
            const el = document.documentElement;
            if (!document.fullscreenElement && !document.webkitFullscreenElement) {
                if (el.requestFullscreen) el.requestFullscreen();
                else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
            } else {
                if (document.exitFullscreen) document.exitFullscreen();
                else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
            }
        }
    </script>

    <!-- uPlot CSS con fallback locale -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/uplot@1.6.30/dist/uPlot.min.css"
          onerror="this.onerror=null; this.href='/uPlot.min.css';">

    <!-- uPlot JS con fallback locale -->
    <script>
        (function() {
            const script = document.createElement('script');
            script.src = 'https://cdn.jsdelivr.net/npm/uplot@1.6.30/dist/uPlot.iife.min.js';
            script.onerror = function() {
                const localScript = document.createElement('script');
                localScript.src = '/uPlot.min.js';
                document.head.appendChild(localScript);
            };
            document.head.appendChild(script);
        })();
    </script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
            min-height: 100vh;
            padding: 5px;
        }

        .container {
            width: 100%;
            background: white;
            padding: 8px;
        }

        /* Header con data/ora e misure */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 5px;
        }

        .datetime {
            font-size: 1em;
            color: #333;
        }

        .datetime .date { font-weight: bold; }
        .datetime .time { font-size: 1.2em; color: #667eea; }

        .current-values {
            display: flex;
            gap: 10px;
        }

        .value-box {
            text-align: center;
            padding: 4px 12px;
            border-radius: 6px;
            background: #f0f0f0;
        }

        .value-box .label {
            font-size: 0.7em;
            color: #666;
        }

        .value-box .value {
            font-size: 1.4em;
            font-weight: bold;
        }

        .value-box.temp .value { color: #ff6384; }
        .value-box.hum .value { color: #36a2eb; }
        .value-box.press .value { color: #9966ff; }
        .value-box.setpoint .value { color: #000000; }

        /* Stile per serie toggle-abili */
        .value-box.toggleable {
            cursor: pointer;
            transition: opacity 0.2s, background-color 0.2s;
        }
        .value-box.toggleable:hover {
            background: #e0e0e0;
        }
        .value-box.toggleable.disabled {
            opacity: 0.4;
            background: #ddd;
        }
        .value-box.toggleable.disabled .value {
            color: #999 !important;
        }

        .value-box.heater {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .heater-dot {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            margin-top: 2px;
            transition: background-color 0.3s;
        }

        .heater-dot.on { background-color: #e53935; }
        .heater-dot.off { background-color: #333; }

        .heater-time {
            font-size: 0.85em;
            color: #e53935;
            font-weight: bold;
            margin-top: 2px;
        }

        /* Grafico */
        .chart-wrapper {
            position: relative;
            width: 100%;
            margin: 5px 0;
            touch-action: none;
        }

        #chart {
            width: 100%;
        }

        /* Legenda overlay (visibile solo su desktop e landscape) */
        #fixed-legend {
            position: absolute;
            top: 8px;
            left: 50px;
            z-index: 10;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 6px 10px;
            pointer-events: none;
            font-size: 0.8em;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .leg-row { display: flex; justify-content: space-between; gap: 12px; }
        .leg-label { color: #666; }
        .leg-val { font-weight: bold; }
        .leg-temp { color: #ff6384; }
        .leg-hum { color: #36a2eb; }
        .leg-press { color: #9966ff; }
        .leg-set { color: #000000; }

        /* Nascondi legenda uPlot di default su desktop/landscape */
        .u-legend { display: none; }

        /* Portrait su mobile: mostra legenda uPlot standard, nascondi overlay */
        @media (max-width: 600px) and (orientation: portrait) {
            #fixed-legend { display: none; }
            .u-legend { display: block; }
        }

        /* Controlli */
        .controls {
            display: flex;
            gap: 8px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 5px;
        }

        button {
            padding: 6px 12px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 13px;
            cursor: pointer;
        }

        .commands-help {
            text-align: center;
            font-size: 0.7em;
            color: #888;
            margin: 3px 0;
        }

        /* Responsive */
        @media (max-width: 600px) {
            .header {
                flex-direction: column;
                text-align: center;
            }

            .current-values {
                width: 100%;
                justify-content: center;
            }

            .value-box {
                flex: 1;
                max-width: 150px;
            }

            .datetime .time {
                font-size: 1.2em;
            }
        }

        #loading {
            text-align: center;
            padding: 20px;
            color: #667eea;
        }

        #error-message {
            background: #fee;
            color: #c33;
            padding: 15px;
            border-radius: 8px;
            display: none;
            text-align: center;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <div class="datetime">
                <div class="date" id="currentDate">--/--/----</div>
                <div class="time" id="currentTime">--:--:--</div>
            </div>
            <div class="current-values">
                <div class="value-box temp toggleable" id="toggleTemp" onclick="toggleSeries('temp')">
                    <div class="label">Temperatura</div>
                    <div class="value" id="currentTemp">--.-°C</div>
                </div>
                <div class="value-box hum toggleable disabled" id="toggleHum" onclick="toggleSeries('hum')">
                    <div class="label">Umidità</div>
                    <div class="value" id="currentHum">--%</div>
                </div>
                <div class="value-box press toggleable disabled" id="togglePress" onclick="toggleSeries('press')">
                    <div class="label">Pressione</div>
                    <div class="value" id="currentPress">---- hPa</div>
                </div>
                <div class="value-box setpoint toggleable" id="toggleSetpoint" onclick="toggleSeries('setpoint')">
                    <div class="label">Setpoint</div>
                    <div class="value" id="currentSetpoint">--.-°C</div>
                </div>
                <div class="value-box heater">
                    <div class="label">Caldaia</div>
                    <div class="heater-dot off" id="heaterDot"></div>
                    <div class="heater-time" id="heaterTime">--:--</div>
                </div>
            </div>
        </div>

        <div id="error-message"></div>
        <div id="loading">Caricamento dati...</div>

        <!-- Grafico uPlot -->
        <div class="chart-wrapper">
            <div id="fixed-legend">
                <div class="leg-row"><span class="leg-label">Ora:</span> <span id="leg-time" class="leg-val">--:--</span></div>
                <div class="leg-row"><span class="leg-label">Temp:</span> <span id="leg-temp" class="leg-val leg-temp">--.-°C</span></div>
                <div class="leg-row"><span class="leg-label">Umidità:</span> <span id="leg-hum" class="leg-val leg-hum">--%</span></div>
                <div class="leg-row"><span class="leg-label">Pressione:</span> <span id="leg-press" class="leg-val leg-press">---- hPa</span></div>
                <div class="leg-row"><span class="leg-label">Setpoint:</span> <span id="leg-set" class="leg-val leg-set">--.-°C</span></div>
            </div>
            <div id="chart"></div>
        </div>

        <div class="commands-help">
            <b>Desktop</b>: rotella zoom, centrale/destro pan, trascina selezione • <b>Touch</b>: 1 dito hover, 2 dita pan + pinch zoom
        </div>

        <!-- Controlli -->
        <div class="controls">
            <button onclick="resetZoom()">Reset Zoom</button>
            <button onclick="toggleFullscreen()" id="fsBtn">Fullscreen</button>
            <button onclick="window.location.href='/update'">Update</button>
        </div>
    </div>

    <script>
        let uplot = null;
        let chartData = null;
        let lastMinute = -1;  // Per rilevare cambio minuto dal termostato
        let programSlots = null;  // 48 valori del programma attivo
        let isViewingToday = true;  // true = oggi (usa programma), false = storico (usa log)

        // Stato visibilità serie (indici in uPlot: 1=heater, 2=temp, 3=hum, 4=setpoint, 5=press)
        let seriesVisible = {
            temp: true,
            hum: false,       // Default: disabilitata
            setpoint: true,
            press: false      // Default: disabilitata
        };

        // Toggle visibilità serie nel grafico
        function toggleSeries(seriesName) {
            seriesVisible[seriesName] = !seriesVisible[seriesName];

            // Aggiorna classe CSS del box
            const box = document.getElementById('toggle' + seriesName.charAt(0).toUpperCase() + seriesName.slice(1));
            if (box) {
                if (seriesVisible[seriesName]) {
                    box.classList.remove('disabled');
                } else {
                    box.classList.add('disabled');
                }
            }

            // Aggiorna visibilità serie in uPlot
            if (uplot) {
                // Mappa nome serie -> indice uPlot
                // Ordine: 0=X, 1=heater, 2=temp, 3=hum, 4=setpoint, 5=press
                const seriesIndex = {
                    temp: 2,
                    hum: 3,
                    setpoint: 4,
                    press: 5
                };

                const idx = seriesIndex[seriesName];
                if (idx !== undefined) {
                    uplot.setSeries(idx, { show: seriesVisible[seriesName] });
                }
            }
        }

        const giorniSettimana = ['domenica', 'lunedì', 'martedì', 'mercoledì', 'giovedì', 'venerdì', 'sabato'];
        const mesi = ['gennaio', 'febbraio', 'marzo', 'aprile', 'maggio', 'giugno',
                      'luglio', 'agosto', 'settembre', 'ottobre', 'novembre', 'dicembre'];

        // Carica programma setpoint (48 slot da 30 min)
        async function loadProgram() {
            try {
                const response = await fetch('/api/program');
                if (!response.ok) return;
                const data = await response.json();
                programSlots = data.slots;
                console.log('Programma caricato:', programSlots.length, 'slot');
            } catch (error) {
                console.error('Errore caricamento programma:', error);
            }
        }

        // Combina dati log (1/min) con setpoint programma (curva a gradini 24h)
        // Il setpoint viene calcolato per ogni timestamp basandosi sullo slot
        function buildTodayData(logData, dayStart) {
            // Funzione per ottenere il setpoint in base al timestamp
            function getSetpointForTime(timestamp) {
                if (!programSlots) return null;
                const secondsFromMidnight = timestamp - dayStart;
                if (secondsFromMidnight < 0 || secondsFromMidnight >= 86400) return null;
                const slot = Math.floor(secondsFromMidnight / 1800);  // 1800 sec = 30 min
                return programSlots[slot];
            }

            // Genera 96 timestamps per il setpoint (bordi degli slot per effetto gradino)
            const setpointTimestamps = [];
            for (let slot = 0; slot < 48; slot++) {
                setpointTimestamps.push(dayStart + slot * 30 * 60);           // Inizio slot
                setpointTimestamps.push(dayStart + (slot + 1) * 30 * 60 - 1); // Fine slot
            }

            // Unisci tutti i timestamps (log + setpoint) e ordina
            const allTimestamps = [...new Set([...logData.timestamps, ...setpointTimestamps])].sort((a, b) => a - b);

            // Crea mappe per lookup veloce dei dati log
            const tempMap = new Map(logData.timestamps.map((t, i) => [t, logData.temps[i]]));
            const humMap = new Map(logData.timestamps.map((t, i) => [t, logData.hums[i]]));
            const pressMap = new Map(logData.timestamps.map((t, i) => [t, logData.pressures[i]]));
            const heaterMap = new Map(logData.timestamps.map((t, i) => [t, logData.heaters[i]]));

            // Costruisci array finali
            const temps = [];
            const hums = [];
            const setpoints = [];
            const pressures = [];
            const heaters = [];

            for (const t of allTimestamps) {
                temps.push(tempMap.has(t) ? tempMap.get(t) : null);
                hums.push(humMap.has(t) ? humMap.get(t) : null);
                setpoints.push(getSetpointForTime(t));  // Calcola setpoint per ogni timestamp
                pressures.push(pressMap.has(t) ? pressMap.get(t) : null);
                heaters.push(heaterMap.has(t) ? heaterMap.get(t) : null);
            }

            return { timestamps: allTimestamps, temps, hums, setpoints, pressures, heaters };
        }

        // Polling status real-time (ogni secondo)
        async function pollStatus() {
            try {
                const response = await fetch('/api/status');
                if (!response.ok) return;

                const data = await response.json();

                // Aggiorna data/ora dal termostato
                if (data.year !== undefined) {
                    const dateStr = giorniSettimana[data.wday] + ' ' + data.day + ' ' + mesi[data.month - 1] + ' ' + data.year;
                    const timeStr = String(data.hour).padStart(2, '0') + ':' +
                                   String(data.min).padStart(2, '0') + ':' +
                                   String(data.sec).padStart(2, '0');
                    document.getElementById('currentDate').textContent = dateStr;
                    document.getElementById('currentTime').textContent = timeStr;

                    // Rileva cambio minuto per aggiornare il grafico
                    if (lastMinute >= 0 && data.min !== lastMinute) {
                        console.log('Minuto cambiato:', lastMinute, '->', data.min);
                        await loadChartData();
                    }
                    lastMinute = data.min;
                }

                // Aggiorna valori header
                document.getElementById('currentTemp').textContent =
                    data.temp !== null ? data.temp.toFixed(1) + '°C' : '--.-°C';
                document.getElementById('currentHum').textContent =
                    data.hum !== null ? data.hum + '%' : '--%';
                document.getElementById('currentPress').textContent =
                    data.press !== null ? data.press + ' hPa' : '---- hPa';
                document.getElementById('currentSetpoint').textContent =
                    data.setpoint !== null ? data.setpoint.toFixed(1) + '°C' : '--.-°C';

                // Aggiorna indicatore caldaia (pallino rosso/nero)
                const heaterDot = document.getElementById('heaterDot');
                if (data.heat === 1) {
                    heaterDot.classList.remove('off');
                    heaterDot.classList.add('on');
                } else {
                    heaterDot.classList.remove('on');
                    heaterDot.classList.add('off');
                }

            } catch (error) {
                console.error('Errore polling status:', error);
            }
        }

        // Avvia polling status ogni secondo
        setInterval(pollStatus, 1000);

        // Carica solo dati grafico (da PSRAM live)
        async function loadChartData() {
            try {
                const response = await fetch('/api/log/current');
                if (!response.ok) return;

                const arrayBuffer = await response.arrayBuffer();
                const parsedData = parseBinaryLog(arrayBuffer);

                if (parsedData.timestamps.length === 0) return;

                chartData = parsedData;
                updateHeaterOnTimeDisplay();

                // Aggiorna dati nel grafico esistente (senza ricreare)
                if (uplot) {
                    // Salva zoom corrente
                    const xMin = uplot.scales.x.min;
                    const xMax = uplot.scales.x.max;
                    const yMin = uplot.scales.y.min;
                    const yMax = uplot.scales.y.max;
                    const y2Min = uplot.scales.y2.min;
                    const y2Max = uplot.scales.y2.max;
                    const y3Min = uplot.scales.y3.min;
                    const y3Max = uplot.scales.y3.max;
                    const y4Min = uplot.scales.y4 ? uplot.scales.y4.min : 0;
                    const y4Max = uplot.scales.y4 ? uplot.scales.y4.max : 1;

                    // Prepara dati (con programma se oggi)
                    let plotData;
                    const today = new Date();
                    today.setHours(0, 0, 0, 0);
                    const dayStart = today.getTime() / 1000;

                    if (isViewingToday && programSlots) {
                        const todayData = buildTodayData(parsedData, dayStart);
                        plotData = [
                            todayData.timestamps,
                            todayData.heaters,      // Caldaia prima (disegnata sotto)
                            todayData.temps,
                            todayData.hums,
                            todayData.setpoints,
                            todayData.pressures
                        ];
                    } else {
                        plotData = [
                            parsedData.timestamps,
                            parsedData.heaters,     // Caldaia prima (disegnata sotto)
                            parsedData.temps,
                            parsedData.hums,
                            parsedData.setpoints,
                            parsedData.pressures
                        ];
                    }

                    // Aggiorna dati
                    uplot.setData(plotData);

                    // Ripristina zoom
                    uplot.setScale('x', { min: xMin, max: xMax });
                    uplot.setScale('y', { min: yMin, max: yMax });
                    uplot.setScale('y2', { min: y2Min, max: y2Max });
                    uplot.setScale('y3', { min: y3Min, max: y3Max });
                    uplot.setScale('y4', { min: y4Min, max: y4Max });
                } else {
                    renderChart(parsedData);
                }

            } catch (error) {
                console.error('Errore caricamento grafico:', error);
            }
        }

        // Carica dati iniziali del giorno corrente
        async function loadTodayData() {
            const loading = document.getElementById('loading');
            const errorDiv = document.getElementById('error-message');

            try {
                // Carica programma setpoint (48 slot)
                await loadProgram();

                // Usa endpoint live da PSRAM
                const response = await fetch('/api/log/current');
                if (!response.ok) throw new Error('Dati non trovati');

                const arrayBuffer = await response.arrayBuffer();
                const parsedData = parseBinaryLog(arrayBuffer);

                if (parsedData.timestamps.length === 0) throw new Error('Nessun dato disponibile');

                chartData = parsedData;
                isViewingToday = true;
                renderChart(parsedData);
                updateHeaterOnTimeDisplay();
                loading.style.display = 'none';

                // Avvia primo polling status
                pollStatus();

            } catch (error) {
                loading.style.display = 'none';
                errorDiv.textContent = error.message;
                errorDiv.style.display = 'block';
            }
        }

        // Parser binario (formato 12 byte con pressione)
        function parseBinaryLog(buffer) {
            const view = new DataView(buffer);
            const numSamples = view.getUint16(9, true);

            const timestamps = [];
            const temps = [];
            const hums = [];
            const setpoints = [];
            const pressures = [];
            const heaters = [];

            let offset = 12;
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const baseTimestamp = today.getTime() / 1000;

            for (let i = 0; i < numSamples; i++) {
                if (offset + 12 > buffer.byteLength) break;

                const minuteOfDay = view.getUint16(offset, true);
                const tempRaw = view.getInt16(offset + 2, true);
                const humRaw = view.getUint8(offset + 4);
                const flags = view.getUint8(offset + 5);
                const setpointRaw = view.getInt16(offset + 6, true);
                const pressRaw = view.getUint16(offset + 10, true);

                timestamps.push(baseTimestamp + minuteOfDay * 60);
                temps.push(tempRaw === -32768 ? null : tempRaw / 100.0);
                hums.push(humRaw === 255 ? null : humRaw);
                setpoints.push(setpointRaw === -32768 ? null : setpointRaw / 100.0);
                pressures.push(pressRaw === 0 ? null : pressRaw);
                heaters.push((flags & 0x01) ? 1 : 0);  // Bit 0 = relay_on
                offset += 12;
            }

            return { timestamps, temps, hums, setpoints, pressures, heaters };
        }

        // Calcola tempo totale accensione caldaia (ritorna stringa hh:mm)
        function calculateHeaterOnTime(heaters) {
            if (!heaters || heaters.length === 0) return '--:--';

            // Conta i minuti in cui la caldaia è ON (ogni sample = 1 minuto)
            let minutesOn = 0;
            for (let i = 0; i < heaters.length; i++) {
                if (heaters[i] === 1) minutesOn++;
            }

            const hours = Math.floor(minutesOn / 60);
            const mins = minutesOn % 60;
            return hours.toString().padStart(2, '0') + ':' + mins.toString().padStart(2, '0');
        }

        // Aggiorna display tempo accensione caldaia
        function updateHeaterOnTimeDisplay() {
            if (chartData && chartData.heaters) {
                const onTime = calculateHeaterOnTime(chartData.heaters);
                document.getElementById('heaterTime').textContent = onTime;
            }
        }

        // Render grafico con uPlot
        function renderChart(data) {
            const container = document.getElementById('chart');
            container.innerHTML = '';

            const width = container.parentElement.clientWidth;
            // Calcola altezza disponibile: viewport - header - controlli - margini
            const header = document.querySelector('.header');
            const controls = document.querySelector('.controls');
            const help = document.querySelector('.commands-help');
            const usedHeight = header.offsetHeight + controls.offsetHeight + help.offsetHeight + 50;
            const height = window.innerHeight - usedHeight;

            // Calcola timestamp mezzanotte di oggi (inizio e fine giornata)
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const dayStart = today.getTime() / 1000;
            const dayEnd = dayStart + 24 * 60 * 60;  // +24 ore

            const opts = {
                width: width,
                height: height,
                cursor: {
                    sync: { key: "sync" },
                    drag: { x: true, y: true }
                },
                scales: {
                    x: {
                        time: true,
                        min: dayStart,
                        max: dayEnd
                    },
                    y: { range: [10, 32] },
                    y2: { range: [0, 100] },
                    y3: { range: [980, 1040] },
                    y4: { range: [0, 1] }  // Scala per caldaia (0=off, 1=on)
                },
                axes: [
                    {
                        stroke: "#666",
                        grid: { stroke: "#eee" },
                        values: (u, vals) => vals.map(v => {
                            const d = new Date(v * 1000);
                            return d.getHours().toString().padStart(2, '0') + ':' +
                                   d.getMinutes().toString().padStart(2, '0');
                        })
                    },
                    {
                        scale: 'y',
                        stroke: "#ff6384",
                        grid: { stroke: "#eee" },
                        values: (u, vals) => vals.map(v => v.toFixed(1) + '°C')
                    },
                    {
                        scale: 'y2',
                        side: 1,
                        stroke: "#36a2eb",
                        grid: { show: false },
                        values: (u, vals) => vals.map(v => v.toFixed(0) + '%')
                    },
                    {
                        scale: 'y3',
                        side: 1,
                        stroke: "#9966ff",
                        grid: { show: false },
                        values: (u, vals) => vals.map(v => v.toFixed(0))
                    }
                ],
                series: [
                    {},  // Serie X (timestamps)
                    {
                        // Caldaia come prima serie (disegnata sotto le altre)
                        label: "Caldaia",
                        stroke: "rgba(229, 57, 53, 0.15)",
                        width: 1,
                        scale: 'y4',
                        fill: "rgba(229, 57, 53, 0.15)",
                        paths: (u, seriesIdx, idx0, idx1) => {
                            const xdata = u.data[0];
                            const ydata = u.data[seriesIdx];

                            let path = new Path2D();
                            let fillPath = new Path2D();

                            for (let i = idx0; i <= idx1; i++) {
                                if (ydata[i] === null) continue;

                                const x0 = u.valToPos(xdata[i], 'x', true);

                                // Estendi di 1 minuto (60 secondi) dal timestamp corrente
                                // Questo rappresenta che per quel minuto la caldaia era in quello stato
                                const x1 = u.valToPos(xdata[i] + 60, 'x', true);

                                const y0 = u.valToPos(0, 'y4', true);
                                const y1 = u.valToPos(ydata[i], 'y4', true);

                                if (ydata[i] > 0) {
                                    fillPath.rect(x0, y1, x1 - x0, y0 - y1);
                                }

                                path.moveTo(x0, y1);
                                path.lineTo(x1, y1);
                            }

                            return { stroke: path, fill: fillPath };
                        }
                    },
                    {
                        label: "Temperatura",
                        stroke: "#ff6384",
                        width: 2,
                        scale: 'y',
                        show: seriesVisible.temp
                    },
                    {
                        label: "Umidità",
                        stroke: "#36a2eb",
                        width: 2,
                        scale: 'y2',
                        show: seriesVisible.hum
                    },
                    {
                        label: "Setpoint",
                        stroke: "#000000",
                        width: 2,
                        scale: 'y',
                        show: seriesVisible.setpoint
                    },
                    {
                        label: "Pressione",
                        stroke: "#9966ff",
                        width: 2,
                        scale: 'y3',
                        show: seriesVisible.press
                    }
                ],
                plugins: [
                    interactionPlugin()
                ]
            };

            let plotData;

            if (isViewingToday && programSlots) {
                // Oggi: usa buildTodayData per 96 punti fissi con programma
                const todayData = buildTodayData(data, dayStart);
                plotData = [
                    todayData.timestamps,
                    todayData.heaters,      // Caldaia prima (disegnata sotto)
                    todayData.temps,
                    todayData.hums,
                    todayData.setpoints,
                    todayData.pressures
                ];
            } else {
                // Storico: usa setpoint dal log
                plotData = [
                    data.timestamps,
                    data.heaters,           // Caldaia prima (disegnata sotto)
                    data.temps,
                    data.hums,
                    data.setpoints,
                    data.pressures
                ];
            }

            uplot = new uPlot(opts, plotData, container);
        }

        // Plugin per zoom/pan su touch e desktop
        function interactionPlugin() {
            return {
                hooks: {
                    setCursor: (u) => {
                        // Aggiorna legenda fissa
                        // Ordine dati: 0=timestamps, 1=heaters, 2=temps, 3=hums, 4=setpoints, 5=pressures
                        const idx = u.cursor.idx;
                        if (idx !== null && idx !== undefined) {
                            const ts = u.data[0][idx];
                            const temp = u.data[2][idx];
                            const hum = u.data[3][idx];
                            const setp = u.data[4][idx];
                            const press = u.data[5] ? u.data[5][idx] : null;

                            const d = new Date(ts * 1000);
                            const timeStr = d.getHours().toString().padStart(2, '0') + ':' +
                                           d.getMinutes().toString().padStart(2, '0');

                            document.getElementById('leg-time').textContent = timeStr;
                            document.getElementById('leg-temp').textContent = temp !== null ? temp.toFixed(1) + '°C' : '--.-°C';
                            document.getElementById('leg-hum').textContent = hum !== null ? hum + '%' : '--%';
                            document.getElementById('leg-press').textContent = press !== null ? press + ' hPa' : '---- hPa';
                            document.getElementById('leg-set').textContent = setp !== null ? setp.toFixed(1) + '°C' : '--.-°C';
                        }
                    },
                    init: (u) => {
                        const plot = u.root.querySelector('.u-over');

                        // === TOUCH: 1 dito = hover, 2 dita = pinch zoom + pan ===
                        let initialPinchDistanceX = null;
                        let initialPinchDistanceY = null;
                        let initialScaleX = null;
                        let initialScaleY = null;
                        let initialScaleY2 = null;
                        let initialScaleY3 = null;
                        let lastPinchCenterX = null;
                        let lastPinchCenterY = null;
                        let panTouchScaleXMin = null;
                        let panTouchScaleXMax = null;
                        let panTouchScaleYMin = null;
                        let panTouchScaleYMax = null;
                        let panTouchScaleY2Min = null;
                        let panTouchScaleY2Max = null;
                        let panTouchScaleY3Min = null;
                        let panTouchScaleY3Max = null;

                        plot.addEventListener('touchstart', (e) => {
                            if (e.touches.length === 2) {
                                e.preventDefault();
                                // Pinch zoom - salva distanze iniziali
                                initialPinchDistanceX = Math.abs(e.touches[0].clientX - e.touches[1].clientX);
                                initialPinchDistanceY = Math.abs(e.touches[0].clientY - e.touches[1].clientY);
                                initialScaleX = u.scales.x.max - u.scales.x.min;
                                initialScaleY = u.scales.y.max - u.scales.y.min;
                                initialScaleY2 = u.scales.y2.max - u.scales.y2.min;
                                initialScaleY3 = u.scales.y3.max - u.scales.y3.min;
                                // Pan - salva centro iniziale
                                lastPinchCenterX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                                lastPinchCenterY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                                panTouchScaleXMin = u.scales.x.min;
                                panTouchScaleXMax = u.scales.x.max;
                                panTouchScaleYMin = u.scales.y.min;
                                panTouchScaleYMax = u.scales.y.max;
                                panTouchScaleY2Min = u.scales.y2.min;
                                panTouchScaleY2Max = u.scales.y2.max;
                                panTouchScaleY3Min = u.scales.y3.min;
                                panTouchScaleY3Max = u.scales.y3.max;
                            } else if (e.touches.length === 1) {
                                // Hover con 1 dito - simula mousemove per cursore uPlot
                                const touch = e.touches[0];
                                const mouseEvent = new MouseEvent('mousemove', {
                                    clientX: touch.clientX,
                                    clientY: touch.clientY,
                                    bubbles: true
                                });
                                plot.dispatchEvent(mouseEvent);
                            }
                        }, { passive: false });

                        plot.addEventListener('touchmove', (e) => {
                            if (e.touches.length === 2 && initialPinchDistanceX !== null) {
                                e.preventDefault();
                                const currentDistanceX = Math.abs(e.touches[0].clientX - e.touches[1].clientX);
                                const currentDistanceY = Math.abs(e.touches[0].clientY - e.touches[1].clientY);
                                const currentCenterX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                                const currentCenterY = (e.touches[0].clientY + e.touches[1].clientY) / 2;

                                // Calcola pan (spostamento del centro)
                                const panDeltaX = currentCenterX - lastPinchCenterX;
                                const panDeltaY = currentCenterY - lastPinchCenterY;

                                // Calcola fattori zoom
                                const zoomFactorX = (initialPinchDistanceX > 20) ? initialPinchDistanceX / currentDistanceX : 1;
                                const zoomFactorY = (initialPinchDistanceY > 20) ? initialPinchDistanceY / currentDistanceY : 1;

                                // Applica zoom + pan combinati su X
                                const newRangeX = initialScaleX * zoomFactorX;
                                const initialCenterX = (panTouchScaleXMin + panTouchScaleXMax) / 2;
                                const pxPerSecX = u.bbox.width / initialScaleX;
                                const panOffsetX = panDeltaX / pxPerSecX;
                                const newCenterX = initialCenterX - panOffsetX;
                                u.setScale('x', {
                                    min: newCenterX - newRangeX / 2,
                                    max: newCenterX + newRangeX / 2
                                });

                                // Applica zoom + pan combinati su Y
                                const newRangeY = initialScaleY * zoomFactorY;
                                const initialCenterY = (panTouchScaleYMin + panTouchScaleYMax) / 2;
                                const pxPerUnitY = u.bbox.height / initialScaleY;
                                const panOffsetY = panDeltaY / pxPerUnitY;
                                const newCenterY = initialCenterY + panOffsetY;
                                u.setScale('y', {
                                    min: newCenterY - newRangeY / 2,
                                    max: newCenterY + newRangeY / 2
                                });

                                // Applica zoom + pan combinati su Y2 (solo se umidità visibile)
                                if (seriesVisible.hum) {
                                    const newRangeY2 = initialScaleY2 * zoomFactorY;
                                    const initialCenterY2 = (panTouchScaleY2Min + panTouchScaleY2Max) / 2;
                                    const pxPerUnitY2 = u.bbox.height / initialScaleY2;
                                    const panOffsetY2 = panDeltaY / pxPerUnitY2;
                                    const newCenterY2 = initialCenterY2 + panOffsetY2;
                                    u.setScale('y2', {
                                        min: newCenterY2 - newRangeY2 / 2,
                                        max: newCenterY2 + newRangeY2 / 2
                                    });
                                }

                                // Applica zoom + pan combinati su Y3 (solo se pressione visibile)
                                if (seriesVisible.press) {
                                    const newRangeY3 = initialScaleY3 * zoomFactorY;
                                    const initialCenterY3 = (panTouchScaleY3Min + panTouchScaleY3Max) / 2;
                                    const pxPerUnitY3 = u.bbox.height / initialScaleY3;
                                    const panOffsetY3 = panDeltaY / pxPerUnitY3;
                                    const newCenterY3 = initialCenterY3 + panOffsetY3;
                                    u.setScale('y3', {
                                        min: newCenterY3 - newRangeY3 / 2,
                                        max: newCenterY3 + newRangeY3 / 2
                                    });
                                }

                            } else if (e.touches.length === 1) {
                                // Hover con 1 dito
                                const touch = e.touches[0];
                                const mouseEvent = new MouseEvent('mousemove', {
                                    clientX: touch.clientX,
                                    clientY: touch.clientY,
                                    bubbles: true
                                });
                                plot.dispatchEvent(mouseEvent);
                            }
                        }, { passive: false });

                        plot.addEventListener('touchend', () => {
                            initialPinchDistanceX = null;
                            initialPinchDistanceY = null;
                            initialScaleX = null;
                            initialScaleY = null;
                            initialScaleY2 = null;
                            initialScaleY3 = null;
                            lastPinchCenterX = null;
                            lastPinchCenterY = null;
                        });

                        // === DESKTOP: pan con tasto centrale o destro (X e Y) ===
                        let isPanning = false;
                        let panStartX = null;
                        let panStartY = null;
                        let panScaleXMin = null;
                        let panScaleXMax = null;
                        let panScaleYMin = null;
                        let panScaleYMax = null;
                        let panScaleY2Min = null;
                        let panScaleY2Max = null;
                        let panScaleY3Min = null;
                        let panScaleY3Max = null;

                        plot.addEventListener('mousedown', (e) => {
                            if (e.button === 1 || e.button === 2) {  // Centrale o destro
                                e.preventDefault();
                                isPanning = true;
                                panStartX = e.clientX;
                                panStartY = e.clientY;
                                panScaleXMin = u.scales.x.min;
                                panScaleXMax = u.scales.x.max;
                                panScaleYMin = u.scales.y.min;
                                panScaleYMax = u.scales.y.max;
                                panScaleY2Min = u.scales.y2.min;
                                panScaleY2Max = u.scales.y2.max;
                                panScaleY3Min = u.scales.y3.min;
                                panScaleY3Max = u.scales.y3.max;
                                plot.style.cursor = 'grabbing';
                            }
                        });

                        plot.addEventListener('mousemove', (e) => {
                            if (isPanning && panStartX !== null) {
                                const deltaX = e.clientX - panStartX;
                                const deltaY = e.clientY - panStartY;

                                // Pan X
                                const pxPerSecX = u.bbox.width / (panScaleXMax - panScaleXMin);
                                const secDelta = deltaX / pxPerSecX;
                                u.setScale('x', {
                                    min: panScaleXMin - secDelta,
                                    max: panScaleXMax - secDelta
                                });

                                // Pan Y (temperatura)
                                const pxPerUnitY = u.bbox.height / (panScaleYMax - panScaleYMin);
                                const yDelta = deltaY / pxPerUnitY;
                                u.setScale('y', {
                                    min: panScaleYMin + yDelta,
                                    max: panScaleYMax + yDelta
                                });

                                // Pan Y2 (umidità) - solo se visibile
                                if (seriesVisible.hum) {
                                    const pxPerUnitY2 = u.bbox.height / (panScaleY2Max - panScaleY2Min);
                                    const y2Delta = deltaY / pxPerUnitY2;
                                    u.setScale('y2', {
                                        min: panScaleY2Min + y2Delta,
                                        max: panScaleY2Max + y2Delta
                                    });
                                }

                                // Pan Y3 (pressione) - solo se visibile
                                if (seriesVisible.press) {
                                    const pxPerUnitY3 = u.bbox.height / (panScaleY3Max - panScaleY3Min);
                                    const y3Delta = deltaY / pxPerUnitY3;
                                    u.setScale('y3', {
                                        min: panScaleY3Min + y3Delta,
                                        max: panScaleY3Max + y3Delta
                                    });
                                }
                            }
                        });

                        plot.addEventListener('mouseup', (e) => {
                            if (e.button === 1 || e.button === 2) {
                                isPanning = false;
                                panStartX = null;
                                panStartY = null;
                                plot.style.cursor = 'default';
                            }
                        });

                        plot.addEventListener('mouseleave', () => {
                            isPanning = false;
                            panStartX = null;
                            panStartY = null;
                            plot.style.cursor = 'default';
                        });

                        plot.addEventListener('contextmenu', (e) => {
                            e.preventDefault();
                        });

                        // === DESKTOP: zoom con rotella ===
                        plot.addEventListener('wheel', (e) => {
                            e.preventDefault();
                            const rect = plot.getBoundingClientRect();
                            const cursorX = e.clientX - rect.left;
                            const cursorRatio = cursorX / rect.width;

                            const scaleMin = u.scales.x.min;
                            const scaleMax = u.scales.x.max;
                            const range = scaleMax - scaleMin;
                            const cursorVal = scaleMin + range * cursorRatio;

                            const zoomFactor = e.deltaY > 0 ? 1.1 : 0.9;
                            const newRange = range * zoomFactor;

                            const newMin = cursorVal - newRange * cursorRatio;
                            const newMax = cursorVal + newRange * (1 - cursorRatio);

                            u.setScale('x', { min: newMin, max: newMax });
                        }, { passive: false });
                    }
                }
            };
        }

        // Reset zoom - mostra sempre 24 ore complete
        function resetZoom() {
            if (uplot) {
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                const dayStart = today.getTime() / 1000;
                const dayEnd = dayStart + 24 * 60 * 60;

                uplot.setScale('x', { min: dayStart, max: dayEnd });
                uplot.setScale('y', { min: 10, max: 32 });
                uplot.setScale('y2', { min: 0, max: 100 });
                uplot.setScale('y3', { min: 980, max: 1040 });
            }
        }

        // Gestione resize
        window.addEventListener('resize', () => {
            if (uplot && chartData) {
                renderChart(chartData);
            }
        });

        // Avvio
        window.onload = loadTodayData;
    </script>
</body>
</html>
