<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#667eea">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="manifest" href="/manifest.json">
    <link rel="apple-touch-icon" href="/icon-192.png">
    <link rel="icon" type="image/png" href="/icon-192.png">
    <title>Cronotermostato</title>

    <script>
        // Toggle fullscreen
        function toggleFullscreen() {
            const el = document.documentElement;
            if (!document.fullscreenElement && !document.webkitFullscreenElement) {
                if (el.requestFullscreen) el.requestFullscreen();
                else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
            } else {
                if (document.exitFullscreen) document.exitFullscreen();
                else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
            }
        }
    </script>

    <!-- uPlot CSS con fallback locale -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/uplot@1.6.30/dist/uPlot.min.css"
          onerror="this.onerror=null; this.href='/uPlot.min.css';">

    <!-- uPlot JS con fallback locale -->
    <script>
        (function() {
            const script = document.createElement('script');
            script.src = 'https://cdn.jsdelivr.net/npm/uplot@1.6.30/dist/uPlot.iife.min.js';
            script.onerror = function() {
                const localScript = document.createElement('script');
                localScript.src = '/uPlot.min.js';
                document.head.appendChild(localScript);
            };
            document.head.appendChild(script);
        })();
    </script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
            min-height: 100vh;
            padding: 5px;
        }

        .container {
            width: 100%;
            background: white;
            padding: 8px;
        }

        /* Header con data/ora e misure */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 5px;
        }

        .datetime {
            font-size: 1em;
            color: #333;
        }

        .datetime .date { font-weight: bold; }
        .datetime .time { font-size: 1.2em; color: #667eea; }

        .current-values {
            display: flex;
            gap: 10px;
        }

        .value-box {
            text-align: center;
            padding: 4px 12px;
            border-radius: 6px;
            background: #f0f0f0;
        }

        .value-box .label {
            font-size: 0.7em;
            color: #666;
        }

        .value-box .value {
            font-size: 1.4em;
            font-weight: bold;
        }

        .value-box.temp .value { color: #ff6384; }
        .value-box.hum .value { color: #36a2eb; }

        /* Grafico */
        .chart-wrapper {
            position: relative;
            width: 100%;
            margin: 5px 0;
            touch-action: none;
        }

        #chart {
            width: 100%;
        }

        /* Legenda overlay (visibile solo su desktop e landscape) */
        #fixed-legend {
            position: absolute;
            top: 8px;
            left: 50px;
            z-index: 10;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 6px 10px;
            pointer-events: none;
            font-size: 0.8em;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .leg-row { display: flex; justify-content: space-between; gap: 12px; }
        .leg-label { color: #666; }
        .leg-val { font-weight: bold; }
        .leg-temp { color: #ff6384; }
        .leg-hum { color: #36a2eb; }
        .leg-set { color: #4bc0c0; }

        /* Nascondi legenda uPlot di default su desktop/landscape */
        .u-legend { display: none; }

        /* Portrait su mobile: mostra legenda uPlot standard, nascondi overlay */
        @media (max-width: 600px) and (orientation: portrait) {
            #fixed-legend { display: none; }
            .u-legend { display: block; }
        }

        /* Controlli */
        .controls {
            display: flex;
            gap: 8px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 5px;
        }

        button {
            padding: 6px 12px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 13px;
            cursor: pointer;
        }

        .commands-help {
            text-align: center;
            font-size: 0.7em;
            color: #888;
            margin: 3px 0;
        }

        /* Responsive */
        @media (max-width: 600px) {
            .header {
                flex-direction: column;
                text-align: center;
            }

            .current-values {
                width: 100%;
                justify-content: center;
            }

            .value-box {
                flex: 1;
                max-width: 150px;
            }

            .datetime .time {
                font-size: 1.2em;
            }
        }

        #loading {
            text-align: center;
            padding: 20px;
            color: #667eea;
        }

        #error-message {
            background: #fee;
            color: #c33;
            padding: 15px;
            border-radius: 8px;
            display: none;
            text-align: center;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <div class="datetime">
                <div class="date" id="currentDate">--/--/----</div>
                <div class="time" id="currentTime">--:--:--</div>
            </div>
            <div class="current-values">
                <div class="value-box temp">
                    <div class="label">Temperatura</div>
                    <div class="value" id="currentTemp">--.-°C</div>
                </div>
                <div class="value-box hum">
                    <div class="label">Umidità</div>
                    <div class="value" id="currentHum">--%</div>
                </div>
            </div>
        </div>

        <div id="error-message"></div>
        <div id="loading">Caricamento dati...</div>

        <!-- Grafico uPlot -->
        <div class="chart-wrapper">
            <div id="fixed-legend">
                <div class="leg-row"><span class="leg-label">Ora:</span> <span id="leg-time" class="leg-val">--:--</span></div>
                <div class="leg-row"><span class="leg-label">Temp:</span> <span id="leg-temp" class="leg-val leg-temp">--.-°C</span></div>
                <div class="leg-row"><span class="leg-label">Umidità:</span> <span id="leg-hum" class="leg-val leg-hum">--%</span></div>
                <div class="leg-row"><span class="leg-label">Setpoint:</span> <span id="leg-set" class="leg-val leg-set">--.-°C</span></div>
            </div>
            <div id="chart"></div>
        </div>

        <div class="commands-help">
            <b>Desktop</b>: rotella zoom, centrale/destro pan, trascina selezione • <b>Touch</b>: 1 dito hover, 2 dita pan + pinch zoom
        </div>

        <!-- Controlli -->
        <div class="controls">
            <button onclick="resetZoom()">Reset Zoom</button>
            <button onclick="toggleFullscreen()" id="fsBtn">Fullscreen</button>
            <button onclick="window.location.href='/storico.html'">Storico</button>
            <button onclick="window.location.href='/update'">Update</button>
        </div>
    </div>

    <script>
        let uplot = null;
        let chartData = null;

        // Aggiorna data/ora
        function updateDateTime() {
            const now = new Date();
            document.getElementById('currentDate').textContent = now.toLocaleDateString('it-IT', {
                weekday: 'long',
                day: 'numeric',
                month: 'long',
                year: 'numeric'
            });
            document.getElementById('currentTime').textContent = now.toLocaleTimeString('it-IT');
        }

        setInterval(updateDateTime, 1000);
        updateDateTime();

        // Carica dati del giorno corrente
        async function loadTodayData() {
            const loading = document.getElementById('loading');
            const errorDiv = document.getElementById('error-message');

            try {
                const dateStr = '20251215';  // Test con file esistente

                const response = await fetch(`/api/log/raw?date=${dateStr}`);
                if (!response.ok) throw new Error('Dati non trovati');

                const arrayBuffer = await response.arrayBuffer();
                const parsedData = parseBinaryLog(arrayBuffer);

                if (parsedData.timestamps.length === 0) throw new Error('File log vuoto');

                chartData = parsedData;
                renderChart(parsedData);
                updateCurrentValues(parsedData);
                loading.style.display = 'none';

            } catch (error) {
                loading.style.display = 'none';
                errorDiv.textContent = error.message;
                errorDiv.style.display = 'block';
            }
        }

        // Parser binario (stesso formato di storico.html)
        function parseBinaryLog(buffer) {
            const view = new DataView(buffer);
            const numSamples = view.getUint16(9, true);

            const timestamps = [];
            const temps = [];
            const hums = [];
            const setpoints = [];

            let offset = 12;
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const baseTimestamp = today.getTime() / 1000;

            for (let i = 0; i < numSamples; i++) {
                if (offset + 10 > buffer.byteLength) break;

                const minuteOfDay = view.getUint16(offset, true);
                const tempRaw = view.getInt16(offset + 2, true);
                const humRaw = view.getUint8(offset + 4);
                const setpointRaw = view.getInt16(offset + 6, true);

                timestamps.push(baseTimestamp + minuteOfDay * 60);
                temps.push(tempRaw === -32768 ? null : tempRaw / 100.0);
                hums.push(humRaw === 255 ? null : humRaw);
                setpoints.push(setpointRaw === -32768 ? null : setpointRaw / 100.0);
                offset += 10;
            }

            return { timestamps, temps, hums, setpoints };
        }

        // Aggiorna valori correnti (ultimo campione)
        function updateCurrentValues(data) {
            const lastIdx = data.temps.length - 1;
            if (lastIdx >= 0) {
                const temp = data.temps[lastIdx];
                const hum = data.hums[lastIdx];

                document.getElementById('currentTemp').textContent =
                    temp !== null ? temp.toFixed(1) + '°C' : '--.-°C';
                document.getElementById('currentHum').textContent =
                    hum !== null ? hum + '%' : '--%';
            }
        }

        // Render grafico con uPlot
        function renderChart(data) {
            const container = document.getElementById('chart');
            container.innerHTML = '';

            const width = container.parentElement.clientWidth;
            // Calcola altezza disponibile: viewport - header - controlli - margini
            const header = document.querySelector('.header');
            const controls = document.querySelector('.controls');
            const help = document.querySelector('.commands-help');
            const usedHeight = header.offsetHeight + controls.offsetHeight + help.offsetHeight + 50;
            const height = window.innerHeight - usedHeight;

            const opts = {
                width: width,
                height: height,
                cursor: {
                    sync: { key: "sync" },
                    drag: { x: true, y: true }
                },
                scales: {
                    x: { time: true },
                    y: { range: [10, 32] },
                    y2: { range: [0, 100] }
                },
                axes: [
                    {
                        stroke: "#666",
                        grid: { stroke: "#eee" },
                        values: (u, vals) => vals.map(v => {
                            const d = new Date(v * 1000);
                            return d.getHours().toString().padStart(2, '0') + ':' +
                                   d.getMinutes().toString().padStart(2, '0');
                        })
                    },
                    {
                        scale: 'y',
                        stroke: "#ff6384",
                        grid: { stroke: "#eee" },
                        values: (u, vals) => vals.map(v => v.toFixed(1) + '°C')
                    },
                    {
                        scale: 'y2',
                        side: 1,
                        stroke: "#36a2eb",
                        grid: { show: false },
                        values: (u, vals) => vals.map(v => v.toFixed(0) + '%')
                    }
                ],
                series: [
                    {},  // Serie X (timestamps)
                    {
                        label: "Temperatura",
                        stroke: "#ff6384",
                        width: 2,
                        scale: 'y',
                        fill: "rgba(255, 99, 132, 0.1)"
                    },
                    {
                        label: "Umidità",
                        stroke: "#36a2eb",
                        width: 2,
                        scale: 'y2',
                        fill: "rgba(54, 162, 235, 0.1)"
                    },
                    {
                        label: "Setpoint",
                        stroke: "#4bc0c0",
                        width: 2,
                        scale: 'y',
                        dash: [5, 5]
                    }
                ],
                plugins: [
                    interactionPlugin()
                ]
            };

            const plotData = [
                data.timestamps,
                data.temps,
                data.hums,
                data.setpoints
            ];

            uplot = new uPlot(opts, plotData, container);
        }

        // Plugin per zoom/pan su touch e desktop
        function interactionPlugin() {
            return {
                hooks: {
                    setCursor: (u) => {
                        // Aggiorna legenda fissa
                        const idx = u.cursor.idx;
                        if (idx !== null && idx !== undefined) {
                            const ts = u.data[0][idx];
                            const temp = u.data[1][idx];
                            const hum = u.data[2][idx];
                            const setp = u.data[3][idx];

                            const d = new Date(ts * 1000);
                            const timeStr = d.getHours().toString().padStart(2, '0') + ':' +
                                           d.getMinutes().toString().padStart(2, '0');

                            document.getElementById('leg-time').textContent = timeStr;
                            document.getElementById('leg-temp').textContent = temp !== null ? temp.toFixed(1) + '°C' : '--.-°C';
                            document.getElementById('leg-hum').textContent = hum !== null ? hum + '%' : '--%';
                            document.getElementById('leg-set').textContent = setp !== null ? setp.toFixed(1) + '°C' : '--.-°C';
                        }
                    },
                    init: (u) => {
                        const plot = u.root.querySelector('.u-over');

                        // === TOUCH: 1 dito = hover, 2 dita = pinch zoom + pan ===
                        let initialPinchDistanceX = null;
                        let initialPinchDistanceY = null;
                        let initialScaleX = null;
                        let initialScaleY = null;
                        let initialScaleY2 = null;
                        let lastPinchCenterX = null;
                        let lastPinchCenterY = null;
                        let panTouchScaleXMin = null;
                        let panTouchScaleXMax = null;
                        let panTouchScaleYMin = null;
                        let panTouchScaleYMax = null;
                        let panTouchScaleY2Min = null;
                        let panTouchScaleY2Max = null;

                        plot.addEventListener('touchstart', (e) => {
                            if (e.touches.length === 2) {
                                e.preventDefault();
                                // Pinch zoom - salva distanze iniziali
                                initialPinchDistanceX = Math.abs(e.touches[0].clientX - e.touches[1].clientX);
                                initialPinchDistanceY = Math.abs(e.touches[0].clientY - e.touches[1].clientY);
                                initialScaleX = u.scales.x.max - u.scales.x.min;
                                initialScaleY = u.scales.y.max - u.scales.y.min;
                                initialScaleY2 = u.scales.y2.max - u.scales.y2.min;
                                // Pan - salva centro iniziale
                                lastPinchCenterX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                                lastPinchCenterY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                                panTouchScaleXMin = u.scales.x.min;
                                panTouchScaleXMax = u.scales.x.max;
                                panTouchScaleYMin = u.scales.y.min;
                                panTouchScaleYMax = u.scales.y.max;
                                panTouchScaleY2Min = u.scales.y2.min;
                                panTouchScaleY2Max = u.scales.y2.max;
                            } else if (e.touches.length === 1) {
                                // Hover con 1 dito - simula mousemove per cursore uPlot
                                const touch = e.touches[0];
                                const mouseEvent = new MouseEvent('mousemove', {
                                    clientX: touch.clientX,
                                    clientY: touch.clientY,
                                    bubbles: true
                                });
                                plot.dispatchEvent(mouseEvent);
                            }
                        }, { passive: false });

                        plot.addEventListener('touchmove', (e) => {
                            if (e.touches.length === 2 && initialPinchDistanceX !== null) {
                                e.preventDefault();
                                const currentDistanceX = Math.abs(e.touches[0].clientX - e.touches[1].clientX);
                                const currentDistanceY = Math.abs(e.touches[0].clientY - e.touches[1].clientY);
                                const currentCenterX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                                const currentCenterY = (e.touches[0].clientY + e.touches[1].clientY) / 2;

                                // Calcola pan (spostamento del centro)
                                const panDeltaX = currentCenterX - lastPinchCenterX;
                                const panDeltaY = currentCenterY - lastPinchCenterY;

                                // Calcola fattori zoom
                                const zoomFactorX = (initialPinchDistanceX > 20) ? initialPinchDistanceX / currentDistanceX : 1;
                                const zoomFactorY = (initialPinchDistanceY > 20) ? initialPinchDistanceY / currentDistanceY : 1;

                                // Applica zoom + pan combinati su X
                                const newRangeX = initialScaleX * zoomFactorX;
                                const initialCenterX = (panTouchScaleXMin + panTouchScaleXMax) / 2;
                                const pxPerSecX = u.bbox.width / initialScaleX;
                                const panOffsetX = panDeltaX / pxPerSecX;
                                const newCenterX = initialCenterX - panOffsetX;
                                u.setScale('x', {
                                    min: newCenterX - newRangeX / 2,
                                    max: newCenterX + newRangeX / 2
                                });

                                // Applica zoom + pan combinati su Y
                                const newRangeY = initialScaleY * zoomFactorY;
                                const initialCenterY = (panTouchScaleYMin + panTouchScaleYMax) / 2;
                                const pxPerUnitY = u.bbox.height / initialScaleY;
                                const panOffsetY = panDeltaY / pxPerUnitY;
                                const newCenterY = initialCenterY + panOffsetY;
                                u.setScale('y', {
                                    min: newCenterY - newRangeY / 2,
                                    max: newCenterY + newRangeY / 2
                                });

                                // Applica zoom + pan combinati su Y2
                                const newRangeY2 = initialScaleY2 * zoomFactorY;
                                const initialCenterY2 = (panTouchScaleY2Min + panTouchScaleY2Max) / 2;
                                const pxPerUnitY2 = u.bbox.height / initialScaleY2;
                                const panOffsetY2 = panDeltaY / pxPerUnitY2;
                                const newCenterY2 = initialCenterY2 + panOffsetY2;
                                u.setScale('y2', {
                                    min: newCenterY2 - newRangeY2 / 2,
                                    max: newCenterY2 + newRangeY2 / 2
                                });

                            } else if (e.touches.length === 1) {
                                // Hover con 1 dito
                                const touch = e.touches[0];
                                const mouseEvent = new MouseEvent('mousemove', {
                                    clientX: touch.clientX,
                                    clientY: touch.clientY,
                                    bubbles: true
                                });
                                plot.dispatchEvent(mouseEvent);
                            }
                        }, { passive: false });

                        plot.addEventListener('touchend', () => {
                            initialPinchDistanceX = null;
                            initialPinchDistanceY = null;
                            initialScaleX = null;
                            initialScaleY = null;
                            initialScaleY2 = null;
                            lastPinchCenterX = null;
                            lastPinchCenterY = null;
                        });

                        // === DESKTOP: pan con tasto centrale o destro (X e Y) ===
                        let isPanning = false;
                        let panStartX = null;
                        let panStartY = null;
                        let panScaleXMin = null;
                        let panScaleXMax = null;
                        let panScaleYMin = null;
                        let panScaleYMax = null;
                        let panScaleY2Min = null;
                        let panScaleY2Max = null;

                        plot.addEventListener('mousedown', (e) => {
                            if (e.button === 1 || e.button === 2) {  // Centrale o destro
                                e.preventDefault();
                                isPanning = true;
                                panStartX = e.clientX;
                                panStartY = e.clientY;
                                panScaleXMin = u.scales.x.min;
                                panScaleXMax = u.scales.x.max;
                                panScaleYMin = u.scales.y.min;
                                panScaleYMax = u.scales.y.max;
                                panScaleY2Min = u.scales.y2.min;
                                panScaleY2Max = u.scales.y2.max;
                                plot.style.cursor = 'grabbing';
                            }
                        });

                        plot.addEventListener('mousemove', (e) => {
                            if (isPanning && panStartX !== null) {
                                const deltaX = e.clientX - panStartX;
                                const deltaY = e.clientY - panStartY;

                                // Pan X
                                const pxPerSecX = u.bbox.width / (panScaleXMax - panScaleXMin);
                                const secDelta = deltaX / pxPerSecX;
                                u.setScale('x', {
                                    min: panScaleXMin - secDelta,
                                    max: panScaleXMax - secDelta
                                });

                                // Pan Y (temperatura)
                                const pxPerUnitY = u.bbox.height / (panScaleYMax - panScaleYMin);
                                const yDelta = deltaY / pxPerUnitY;
                                u.setScale('y', {
                                    min: panScaleYMin + yDelta,
                                    max: panScaleYMax + yDelta
                                });

                                // Pan Y2 (umidità)
                                const pxPerUnitY2 = u.bbox.height / (panScaleY2Max - panScaleY2Min);
                                const y2Delta = deltaY / pxPerUnitY2;
                                u.setScale('y2', {
                                    min: panScaleY2Min + y2Delta,
                                    max: panScaleY2Max + y2Delta
                                });
                            }
                        });

                        plot.addEventListener('mouseup', (e) => {
                            if (e.button === 1 || e.button === 2) {
                                isPanning = false;
                                panStartX = null;
                                panStartY = null;
                                plot.style.cursor = 'default';
                            }
                        });

                        plot.addEventListener('mouseleave', () => {
                            isPanning = false;
                            panStartX = null;
                            panStartY = null;
                            plot.style.cursor = 'default';
                        });

                        plot.addEventListener('contextmenu', (e) => {
                            e.preventDefault();
                        });

                        // === DESKTOP: zoom con rotella ===
                        plot.addEventListener('wheel', (e) => {
                            e.preventDefault();
                            const rect = plot.getBoundingClientRect();
                            const cursorX = e.clientX - rect.left;
                            const cursorRatio = cursorX / rect.width;

                            const scaleMin = u.scales.x.min;
                            const scaleMax = u.scales.x.max;
                            const range = scaleMax - scaleMin;
                            const cursorVal = scaleMin + range * cursorRatio;

                            const zoomFactor = e.deltaY > 0 ? 1.1 : 0.9;
                            const newRange = range * zoomFactor;

                            const newMin = cursorVal - newRange * cursorRatio;
                            const newMax = cursorVal + newRange * (1 - cursorRatio);

                            u.setScale('x', { min: newMin, max: newMax });
                        }, { passive: false });
                    }
                }
            };
        }

        // Reset zoom
        function resetZoom() {
            if (uplot && chartData) {
                const minT = Math.min(...chartData.timestamps);
                const maxT = Math.max(...chartData.timestamps);
                uplot.setScale('x', { min: minT, max: maxT });
                uplot.setScale('y', { min: 10, max: 32 });
                uplot.setScale('y2', { min: 0, max: 100 });
            }
        }

        // Gestione resize
        window.addEventListener('resize', () => {
            if (uplot && chartData) {
                renderChart(chartData);
            }
        });

        // Avvio
        window.onload = loadTodayData;
    </script>
</body>
</html>
